先附上官方的文档：https://docs.scala-lang.org/tour/implicit-conversions.html

隐式转换是Scala的重要特性，但也是许多新手撤离Scala阵营的元凶之一。许多新手入坑Scala都是因为akka和spark。但是，一看akka(尤其是akka-http)、spark源码，里面来路不明的隐式参数瞬间就能让人懵逼。本文主要总结以下几个方面的问题，弄清楚这几个问题后，我认为对于akka、spark源码中隐式转换部分就能够正确理解了，并且能够在初步使用隐式转换优化部分功能实现：

1. 隐式函数、隐式类、隐式参数的定义方式；

2. 隐式函数、隐式类、隐式参数、隐式证明等常见的使用场景和使用方法；

3. 编译器处理隐式转换的一些原则；

4. 编译器搜索隐式参数的方式，即隐式参数的实际来源；

5. Scala常见的隐式参数及其使用方式。
---

- 隐式函数

所谓的隐式函数就是在定义时比普通函数多了一个implicit关键字。 

```
implicit def rmb2Gold(stone: Stone): Gold = stone.toGold 
```

- 隐式类

隐式类的定义时比普通类多了一个implicit关键字；

隐式类的主构造器必须接受一个对象；

隐式类不能单独定义，它必须定义在某个类或伴生对象内部。

```
object ImplicitClass {

  implicit class CXKExtension(cxk: CXK) { ... } // 接受一个CXK对象
}
```
---
隐式转换的语法是很简单的，那么怎么使用？

**隐式函数的使用：**

隐式函数是最容易理解的，即对类型进行转换。它的使用场景也比较单一，即在需要时对类型进行转换。
```
  implicit def rmb2Gold(rmb: RMB): Gold = rmb.toGold // 隐式函数

  def buyHouse(gold: Gold): String = { "got a house" }

  val rmb = RMB()

  val rmb = RMB()
  assert(buyHouse(rmb) == "got a house") // 在buyHouse进行调用时，编译器隐式的利用rmb2Gold将rmb转换成了Gold对象，函数才得以正常执行。
  
  val dollar = Dollar()
  assert(buyHouse(dollar) == "got a house")
```
buyHouse需要参数Gold，而你只能得到RMB或Dollar的对象，这时候就可以尝试使用隐式函数将RMB和Dollar转换成Gold。**编译器会搜索能够将RMB/Doolar对象转换成Gold对象的隐式函数，并在调用buyHouse时完成自动转换**。

看起来这个隐式函数可能比较鸡肋，buyHouse(rmb.toGold)不也能够直接调用，无需定义隐式函数。但这仅仅是一个简单的例子，在处理各种类型关系复杂的业务逻辑时，隐式函数是有助于提高代码的可扩展性、可读性和可复用性的，同时能够避免一些问题，使用最广泛的例子便是磁铁模式。

另外，为了提高代码的可读性，隐式函数最好命名为source2Target，并且函数返回类型最好手动给出。如果靠编译器推断隐式函数的返回类型，可能导致隐式函数匹配失败，特别是在对接受隐式函数的泛型方法进行反射时，偶尔遇到这种问题，到底是为啥我也没深究。

**隐式类的使用：**  
如果隐式函数的主要用途在于“转换”，那么隐式类的主要用途就在于“增强”了。**利用隐式类可以增强某个类的功能，这里的“增强”是只增加类的方法和字段，做不到向函数“织入”逻辑(AOP)**。

隐式类的使用理解起来可能没有隐式函数那么直观。





